# miniopt(executable)
A command line option code generator.

# Usage
```
miniopt [option] <file>

It is a code generator for command line options.

Options:
  -o --out <file>   specify output filename.
  -h --help         show help.
  -v --version      show version.
```

## Input template
It is a template, and the user should make sure no duplicate option(name)s exist when use it.
```
app-name...

some lines of description...

Options: 
  -k,--key=<value>     description...
  -k,--key <value>     description...
  -k --key=<value>     description...
  -k --key <value>     description...
  -k,--key             description...
  --key=<val>          description...
  --key <val>          description...
  -k<val>              description...
  -k=<val>             description...
  -k <val>             description...
  -k                   description...
```
Follow is an input example.
```
myapp [option] <source>

It is used to do some great works.

Options: 
  -a --append=<key=value>   append key and value.
  -r --remove <key>         remove key.
  -q --query=<key>          query key.
  -m --modify <key=value>   modify key.
  -l --list                 list keys.
     --offset=<n>           list offset number.
     --limit <n>            list size.
  -d<val>                   define something.
  -e=<val>                  any description1.
  -f <val>                  any description2.
  -g                        any description3.
```

Follow is the generated code.
```C
// Generated by miniopt version 0.1.0 Sun Jul 31 16:23:16 2022

#include "miniopt.h"
#include <stdio.h>

int ParseArgs(int argc, char *argv[]) {
    option options[] = {
        {'a', "append", "<key=value>", "append key and value."},
        {'r', "remove", "<key>", "remove key."},
        {'q', "query", "<key>", "query key."},
        {'m', "modify", "<key=value>", "modify key."},
        {'l', "list", nil, "list keys."},
        {nil, "offset", "<n>", "list offset number."},
        {nil, "limit", "<n>", "list size."},
        {'d', nil, "<val>", "define something."},
        {'e', nil, "<val>", "any description1."},
        {'f', nil, "<val>", "any description2."},
        {'g', nil, nil, "any description3."}
    };
    const int optsum = sizeof(options) / sizeof(options[0]);

    if (miniopt.init(argc, (char **)argv, options, optsum) != 0) {
        printf("error: %s\n", miniopt.what());
        return 0;
    }

    int status;
    while ((status = miniopt.getopt()) > 0) {
        int id = miniopt.optind();
        switch (id) {
            case 0: // -a --append <key=value>
                // <key=value> = miniopt.optarg()
            break;
            case 1: // -r --remove <key>
                // <key> = miniopt.optarg()
            break;
            case 2: // -q --query <key>
                // <key> = miniopt.optarg()
            break;
            case 3: // -m --modify <key=value>
                // <key=value> = miniopt.optarg()
            break;
            case 4: // -l --list
            break;
            case 5: //    --offset <n>
                // <n> = miniopt.optarg()
            break;
            case 6: //    --limit <n>
                // <n> = miniopt.optarg()
            break;
            case 7: // -d <val>
                // <val> = miniopt.optarg()
            break;
            case 8: // -e <val>
                // <val> = miniopt.optarg()
            break;
            case 9: // -f <val>
                // <val> = miniopt.optarg()
            break;
            case 10: // -g
            break;
            default:
            printf("[non-opt-arg] arg = [%s]\n", miniopt.optarg());
            break;
        }
    }

    if (status < 0) printf("error: %s\n", miniopt.what());

    printf("\nOptions:\n");
    miniopt.printopts(printf, 2);

    return status;
}

int main(int argc, char* argv[]){
    return ParseArgs(argc, argv);
}
```